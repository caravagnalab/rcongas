---
title: "Filtering functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Filtering functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# options(crayon.enabled = FALSE)

# knitr::opts_chunk$set(
#   collapse = TRUE,
#   comment = "%>"
# )

# old_hooks <- fansi::set_knit_hooks(knitr::knit_hooks, 
#                                    which = c("output", "message", "error"))

options(crayon.enabled = FALSE)
# options(pillar.bold = TRUE, pillar.subtle_num = TRUE)
# 
# colourise_chunk <- function(type) {
#   function(x, options) {
#     lines <- x
#     if (type != "output") {
#       # lines <- crayon::red(lines)
#     }
#     paste0(
#       '<div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">',
#       paste0(
#         fansi::sgr_to_html(htmltools::htmlEscape(lines)),
#         collapse = "\n"
#       ),
#       "</code></pre></div>"
#     )
#   }
# }
# 
# knitr::knit_hooks$set(
#   output = colourise_chunk("output"),
#   message = colourise_chunk("message"),
#   warning = colourise_chunk("warning"),
#   error = colourise_chunk("error")
# )

knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r, warning=FALSE, message=FALSE}
library(Rcongas)
library(dplyr)
library(ggplot2)
```


<!-- ```{r, eval=T} -->
<!-- data('example_object') -->
<!-- print(example_object) -->
<!-- ``` -->

Filtering functions are available to process data before or after it is loaded into the package.

* pre-process data that is ready for usage in the tool, returning an equivalent tibble with fewer rows;

* process data that has already being inputed to the tool, returning a new `rcongasplus` object.

## Filtering count data

```{data}
data("example_input")
```

### Known genes


Ribosomal (`r`) and mitochondrial (`m`) genes can be removed with function `filter_known_genes`. This function takes in input a `what` parameter (default `mr`) which determines what genes should be removed, plus an extra `specials` list of gene names to remove. 

```{r}
# The default value for `specials`
formals(filter_known_genes)$specials
```

Mitochondrial and ribosomal genes are identified by name using regular expression `"MT"` or `"RP[SL]"`, respectively.

> To use this filter tf the input RNA data must contain a `gene` column.


```{r}
example_input$rna %>% print

# Remove default 
example_input$rna %>% filter_known_genes()
```

Remove only ribosomal genes.

```{r}
example_input$rna %>% filter_known_genes(what = 'r', specials = list())
```


### Outliers

Certain genes can have very high counts in certain cells. 

```{r, fig.width=4, fig.height=8}
# Plot the distribution of maxima for each gene count (RNA data)
my_view = function(x) x %>% 
  group_by(gene) %>% 
  filter(value == max(value)) %>% # max only
  ggplot(aes(value)) + 
  geom_histogram(bins = 70) +
  scale_y_log10() +
  theme_linedraw() +
  xlim(0, 1000)
  

cowplot::plot_grid(
  example_input$rna %>% my_view,
  example_input$rna %>% 
    filter_counts_by_quantile %>% # Filter
    my_view,
  nrow = 2
)
```

These outliers will affect the overall counts per segment used by `Rcongas` models, and can  be removed using function `filter_counts_by_quantile`, which computes an empirical quantile $q$ per event in the data (gene for RNA and peaks for ATAC).

The default quantile value for $q$ is 98% (`upper_quantile = .98`).

```{r, fig.width=4, fig.height=4}
```

## Filtering mapped data

```{r}
data("example_object")

example_object %>% print()
```

### Segments

```{r, fig.width=5, fig.height=5}
example_object %>% 
  plot_data(what = 'mapping')
```

Segments that are too short, or have few mapped RNA genes or ATAC peaks can
be removed using function `filter_segments`.


```{r, fig.width=5, fig.height=3}
# Retain segments longer than 100 Megabases
example_object %>% 
  filter_segments(length = 1e8, RNA_genes = 0, ATAC_peaks = 0) %>% 
  plot_data(what = 'mapping')
```

### Outliers per segments

After mapping counts data to segments, a function
can be used to determine quantiles of mapped data, for every cell, and identify
outliers in each segment and modality. 

Outliers are identified by using a quantile range $q = (q_l, q_r)$ with 
$q_r,q_l\in [0,1]$ reporting lower and upper quantiles. The quantiles 
are computed and applied per segment. 

For every cell we count how often that is an oulier - i.e., in how many of the
input segments - and remove it if this frequency si above a certain cutoff.


```{r fig.width=8, fig.height=5}
# Some segments from the object
segment_id = example_object %>%
  get_input('segmentation') %>%
  pull(segment_id)

segment_id = segment_id[1:4]

# Original segment plot
example_object %>% 
  plot_data(what = 'histogram', segments = segment_id)

# Filter with 5%/95% values
example_object %>% 
  filter_outliers(lower_quantile = .05, upper_quantile = .95) %>% 
  plot_data(what = 'histogram', segments = segment_id)
```


<!-- > If you used \code{action = 'remove'} The returned object will contain fewer entries; it should be checked for an excess of zeros after filtering. We show an example below -->

<!-- Compare 0-count cells before and after the filter -->

<!-- ```{r} -->
<!-- # RNA 0-counts difference -->
<!-- stat(example_object)$zero_counts_cells_RNA %>% print -->
<!-- stat(f_example_object)$zero_counts_cells_RNA %>% print  # capped -->
<!-- stat(f2_example_object)$zero_counts_cells_RNA %>% print # removed -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # ATAC 0-counts difference -->
<!-- stat(example_object)$zero_counts_cells_ATAC %>% print -->
<!-- stat(f_example_object)$zero_counts_cells_ATAC %>% print  # capped -->
<!-- stat(f2_example_object)$zero_counts_cells_ATAC %>% print # removed -->
<!-- ``` -->

<!-- The extent of the new 0-counts cells can be summarised printing the filtered object to console. -->

<!-- ```{r} -->
<!-- f_example_object %>% print -->
<!-- f2_example_object %>% print -->
<!-- ``` -->

### Cells with missing data

Some cells can have have 0-counts because they have no events mapping to a certain segment, or because some heavy filtering inflated the number of 0-count cells. These generally count as _missing data_

> Missing data will be imputed to have value 0 before fit, and excessive 0s will force the model use mixture components peaked at 0. We suggest therefore to remove these entries or at least try to keep their number to a minimum.

A filter is available to remove cells with missing data above a proportion $p\in[0,1]$ of the number of input segments (e.g., all cells with >20% of segments with missing data).

The presence of missing data is reported by a print to console of an object. 

```{r}
example_object %>% print
```

Now we apply the filter (e.g., `proportion_RNA = 0` means that cells with >0 missing data are removed).

```{r}
example_object = example_object %>% filter_missing_data(proportion_RNA = 0, proportion_ATAC = 0)
```

Now the object has fewer cells.
```{r}
example_object %>% print
```

